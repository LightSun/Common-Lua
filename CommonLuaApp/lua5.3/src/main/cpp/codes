
=========== luaL_openlibs2 ===============
add -----
#include "../luaextra/lua_internal.h"
#include "lauxlib.h"
----------

LUALIB_API void luaL_openlibs2(lua_State *L, const luaL_Reg libs[]) {
  const luaL_Reg *lib;
  /* "require" functions from 'loadedlibs' and set results to global table */
  for (lib = libs; lib->func; lib++) {
    luaL_requiref(L, lib->name, lib->func, 1);
    lua_pop(L, 1);  /* remove lib */
  }
}


============= searcher_Lua ================
static int searcher_Lua (lua_State *L) {
  const char *filename;
  const char *name = luaL_checkstring(L, 1);
  filename = findfile(L, name, "path", LUA_LSUBSEP);
  //============= HEAVEN7 start ==========
  if(filename == NULL){
    filename = getLuaFilename(name);
  }
  //============ HEAVEN7 end =======
  if (filename == NULL) return 1;  /* module not found in this path */
  return checkload(L, (luaL_loadfile(L, filename) == LUA_OK), filename);
}

================== searcher_C =======================
static int searcher_C (lua_State *L) {
  const char *name = luaL_checkstring(L, 1);
  const char *filename = findfile(L, name, "cpath", LUA_CSUBSEP);

  //============= HEAVEN7 start ==========
  if(filename == NULL){
    filename = getCLibFilename(name);
  }
  //============ HEAVEN7 end =======

  if (filename == NULL) return 1;  /* module not found in this path */
  return checkload(L, (loadfunc(L, filename, name) == 0), filename);
}

=============== dumpStack ==============
  lbaselib.c :    {"dumpStack", luaB_dumpStack},


  ===================== lua.h ===============
  #include "config.h"

  =====================lgc.c : clearkeys  =======================
  static void clearkeys (global_State *g, GCObject *l, GCObject *f) {
    for (; l != f; l = gco2t(l)->gclist) {
      Table *h = gco2t(l);
      Node *n, *limit = gnodelast(h);
      for (n = gnode(h, 0); n < limit; n++) {
        //this will cause a bug that null value of string key. never clear.
        //@see 'http://lua-users.org/lists/lua-l/2017-08/msg00065.html'
        //if (!ttisnil(gval(n)) && (iscleared(g, gkey(n)))) {
        if ((iscleared(g, gkey(n)))) {
          setnilvalue(gval(n));  /* remove value ... */
          removeentry(n);  /* and remove entry from table */
        }
      }
    }
  }

  ===============================

  #include "../luaextra/lua_internal.h"
  //load lua source.
  LUALIB_API int luaL_loadfilex (lua_State *L, const char *filename,
                                               const char *mode) {
    LoadF lf;
    int status, readstatus;
    int c;
    int fnameindex = lua_gettop(L) + 1;  /* index of filename on the stack */
    if (filename == NULL) {
      lua_pushliteral(L, "=stdin");
      lf.f = stdin;
    }
    else {
      lua_pushfstring(L, "@%s", filename);
      lf.f = fopen(filename, "r");
      if (lf.f == NULL) return errfile(L, "open", fnameindex);
    }
    int handled = 0;
    // txt or binary
    if (skipcomment(&lf, &c)) { /* read initial portion */
        lf.buff[lf.n++] = '\n';  /* add line to correct line numbers */
    } else{
        //--------------------- start h7 ---------------
        if(filename){
            lf.f = freopen(filename, "rb", lf.f);  /* reopen in binary mode */
            if (lf.f == NULL) return errfile(L, "reopen", fnameindex);
            size_t sz;
            char        file_header[BF_HEADER_SIZE];
            // check file header
            sz = fread(file_header, 1, BF_HEADER_SIZE, lf.f);
            if (sz == BF_HEADER_SIZE && memcmp(file_header, BF_HEADER, BF_HEADER_SIZE - 1) == 0) {
                // de file
                lf.f = ext_decode(lf.f, BF_HEADER_SIZE, filename);
                if(lf.f == NULL){
                    return errfile(L, "decode lua failed.", fnameindex);
                }
                fseek(lf.f, 0L, SEEK_SET);
                skipcomment(&lf, &c);  /* re-read initial portion */
                lf.buff[lf.n++] = '\n';  /* add line to correct line numbers */
                handled = 1;
            } else{
                fseek(lf.f, 0L, SEEK_SET);
            }
            //--------------------- end h7 ---------------
        }
    }
      if (handled == 0 && c == LUA_SIGNATURE[0] && filename) {  /* binary file? */
          lf.f = freopen(filename, "rb", lf.f);  /* reopen in binary mode */
          if (lf.f == NULL) return errfile(L, "reopen", fnameindex);
          skipcomment(&lf, &c);  /* re-read initial portion */
      }

    if (c != EOF)
      lf.buff[lf.n++] = c;  /* 'c' is the first character of the stream */
    status = lua_load(L, getF, &lf, lua_tostring(L, -1), mode);
    readstatus = ferror(lf.f);
    if (filename) fclose(lf.f);  /* close file (even in case of errors) */
    if (readstatus) {
      lua_settop(L, fnameindex);  /* ignore results from 'lua_load' */
      return errfile(L, "read", fnameindex);
    }
    lua_remove(L, fnameindex);
    return status;
  }

//================================== global_State
#ifdef __USE_PTHREAD
    pthread_mutex_t lock;
#endif

=============== LUA_API lua_State *lua_newstate (lua_Alloc f, void *ud) =======================
 pthread_mutex_init(&g->lock, NULL);


 ================================ luaB_print =========================
 #include "../luaextra/lua_internal.h"
 static int luaB_print (lua_State *L) {
   int n = lua_gettop(L);  /* number of arguments */
   int i;
   for (i = 1; i <= n; i++) {  /* for each argument */
     size_t l;
     const char *s = luaL_tolstring(L, i, &l);  /* convert it to string */
     if (i > 1) {  /* not the first element? */
       //lua_writestring("\t", 1);  /* add a tab before it */
       __printImpl("\t", 1, 0);
     }
     //lua_writestring(s, l);  /* print it */
     __printImpl(s, l, 0);
     lua_pop(L, 1);  /* pop result */
   }
   //lua_writeline();
   __flushPrint();
   return 0;
 }